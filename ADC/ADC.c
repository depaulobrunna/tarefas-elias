#include "stm32f4xx.h"                  // Device header

#define A GPIO_ODR_ODR_12 

uint8_t data;
uint8_t data2 = 0;
int main(void){
	#if 1
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;//habilita o clock da porta A
	GPIOD->MODER |= GPIO_MODER_MODER12_0;
	
	
	GPIOD->ODR |= A;
	//GPIO ADC CFG
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER |= GPIO_MODER_MODE7_0| GPIO_MODER_MODE7_1;
	/*GPIOA->MODER &= ~(GPIO_MODER_MODE13_0| GPIO_MODER_MODE13_1|
										GPIO_MODER_MODE14_0| GPIO_MODER_MODE14_1|
										GPIO_MODER_MODE15_0| GPIO_MODER_MODE15_1);*/
	
	//confg pin timmer 
	/*RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
	GPIOB -> MODER |= GPIO_MODER_MODER3_1;//MODO AF
	GPIOB-> AFR[0] |= 1 << 12 ;
	GPIOB->OSPEEDR |= 3 << GPIO_OSPEEDR_OSPEED3_Pos;*/
	
	
	/*RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	
	TIM2->PSC = 1600 - 1;//VALOR PELO QUAL O CLOCK INICIAL É DIVIDIDO
	TIM2->ARR = 10 - 1;
	TIM2->CR1 |= TIM_CR1_CEN|
							 TIM_CR1_ARPE;*/
	
	//ADC CFG
	RCC->APB2ENR |= RCC_APB2ENR_ADC2EN;
	//ADC->CCR = 0 << ADC_CCR_ADCPRE_Pos;
	ADC2->CR2 &= ~ADC_CR2_ADON;
	
	
	
	ADC2->CR1 |= ADC_CR1_RES_1;//ADC 8 BITS
	ADC2->CR1 &= ~ADC_CR1_AWDEN;
	ADC2->SQR1 = 0 << ADC_SQR1_L_Pos;//N DE CONV = 1
	ADC2->SQR2 = 1 << ADC_SQR2_SQ7_Pos;//SEQ DO CANAL, JOGA NO REGISTRADOR RESPECTIVO O NUMERO DA SUA ORDEM DE LEITURA
	ADC2->SMPR2 = 0 << ADC_SMPR2_SMP7_Pos;//SAMPLE TIME 3 CYCLES
	
	
	#endif
	while(1)
	{
		#if 1
		ADC2->CR2 |= ADC_CR2_ADON;
		ADC2->CR2 |= ADC_CR2_SWSTART;//COMECA A CONV
		GPIOD->ODR ^= A;
		
		while(!(ADC->CSR & ADC_CSR_EOC2));//ESPERA A CONVERSAO TERMINAR
		ADC->CSR &= ~ADC_CSR_EOC2;
		data2 = ADC2-> DR;//ARMAZENA OS DADOS
		//ADC2->CR2 &= ~ADC_CR2_ADON;
#endif
	}
}

